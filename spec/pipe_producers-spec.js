/*globals describe, it, expect, waitsFor, runs, jasmine, beforeEach, afterEach, JSPipe */

describe('timeout', function() {

    it('returns a new Pipe', function() {
        var ret = JSPipe.timeout();
        expect(ret instanceof JSPipe.Pipe).toEqual(true);
    });

    it('waits the specified miliseconds and then puts that value into the returned Pipe', function() {
        var expected = 10,
            pipe = JSPipe.timeout(expected),
            actual;

        JSPipe.job(function* () {
            actual = yield pipe.get();
        });

        waitsFor(function() {
            return actual !== undefined;
        });

        runs(function() {
            expect(actual).toEqual(expected);
        });
    });

    it('closes the Pipe after the time has elapsed', function() {
        var pipe = JSPipe.timeout(100),
            expected = [true, false],
            actual = [];

        actual.push(pipe.isOpen);

        waitsFor(function() {
            return pipe.isOpen === false;
        });

        runs(function() {
            actual.push(pipe.isOpen);
            expect(actual).toEqual(expected);
        });
    });
    
});


describe('listen', function() {

    var pipe, event;

    beforeEach(function() {
        pipe = JSPipe.listen(document, 'click');
        event = document.createEvent('MouseEvents');
        event.initMouseEvent('click', true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);       
    });

    afterEach(function() {
        pipe.close();
    });

    it('returns a new EventPipe', function() {
        expect(pipe instanceof JSPipe.EventPipe).toEqual(true);        
    });

    it('sends the event data to the EventPipe when the event occurs', function() {
        var expected = document,
            actual = [];

        event.initMouseEvent('click', true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);        
        document.dispatchEvent(event);

        JSPipe.job(function* () {
            actual.push(yield pipe.get());
        });

        waitsFor(function() {
            return actual.length > 0;
        });

        runs(function() {
            expect(actual[0].srcElement).toEqual(expected);
        });

    });

    it('can call preventDefault when the event is handled', function() {
        var eventDataFromPipe;

        pipe = JSPipe.listen(document, 'click', true);
        
        JSPipe.job(function* () {
            eventDataFromPipe = yield pipe.get();
        });
        
        document.dispatchEvent(event);        

        waitsFor(function() {
            return eventDataFromPipe !== undefined;
        });

        runs(function() {
            expect(eventDataFromPipe.defaultPrevented).toEqual(true);
        });
    });
    
});



describe('lazyseq', function() {

    var pipe;

    function producer(i) {
        return 'data ' + i;
    }

    beforeEach(function() {
        pipe = JSPipe.lazyseq(3, producer);
    });

    it('returns a new Pipe', function() {
        expect(pipe instanceof JSPipe.Pipe).toEqual(true);
    });

    it('puts "count" number of items, each generated by the "fn" argument, into the pipe and then closes the pipe', function() {
        var expected = ['data 0', 'data 1', 'data 2', JSPipe.sentinel], // TODO: get rid of sentinel 
            actual = [];

        JSPipe.job(function* () {
            var data;
            while (data = yield pipe.get()) {
                actual.push(data);
            }
        });

        waitsFor(function() {
            return pipe.isOpen === false;
        });

        runs(function() {
            expect(actual).toEqual(expected);
        });
        
    });

});

describe('denode', function() {

    var pipe;

    function nodeStyleFunction(arg0, arg1, callback) {
        callback(null, 1);
        callback(null, 2);
    }
    
    it('produces a pipe that gets data when the supplied function invokes its callback', function() {
        var expected = [1, 2],
            actual = [];

        pipe = JSPipe.denode(nodeStyleFunction, ['a', 'b']);

        JSPipe.job(function* () {
            var el;
            while (el = yield pipe.get()) {
                actual.push(el.data);
            }
        });

        waitsFor(function() {
            return actual.length === 2;
        });

        runs(function() {
            expect(actual).toEqual(expected);
        });
    });
});

